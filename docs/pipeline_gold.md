# Camada Gold

## Mostrando todos os arquivos da camada silver

```python
display(dbutils.fs.ls(f"/mnt/{storageAccountName}/silver"))
```

## Gerando um dataframe dos delta lake no container bronze do Azure Data Lake Storage

```python
df_agendamentos = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/agendamentos")
df_cargas = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/cargas")
df_clientes = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/clientes")
df_motoristas = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/motoristas")
df_rotas = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/rotas")
df_veiculos = spark.read.format('delta').load(f"/mnt/{storageAccountName}/silver/veiculos")
```

## Criando tabelas dimensão

### Agendamentos

#### Cria tabela

```sql
%sql
CREATE TABLE IF NOT EXISTS dim_agendamentos (
    sk_agendamentos BIGINT GENERATED BY DEFAULT AS IDENTITY,
    data_hora_coleta DATE,
    data_hora_entrega DATE,
    veiculo_id INT,
    carga_id INT
)
USING delta
LOCATION '/mnt/datalake7a68c04c876ba15d/gold/dim_agendamentos';
```

#### Cria uma tabela temporária 

```python
df_agendamentos.createOrReplaceTempView("temp_agendamentos")
```

#### Da merge nos dados da tabela dimensional e temporária

```sql
%sql
MERGE INTO dim_agendamentos AS da
USING temp_agendamentos AS ta
ON da.veiculo_id = ta.codigo_veiculo AND da.carga_id = ta.codigo_carga
WHEN MATCHED AND (
    da.data_hora_coleta <> ta.data_hora_coleta OR 
    da.data_hora_entrega <> ta.data_hora_entrega
) THEN
  UPDATE SET 
    da.data_hora_coleta = ta.data_hora_coleta,
    da.data_hora_entrega = ta.data_hora_entrega,
    da.veiculo_id = ta.codigo_veiculo,
    da.carga_id = ta.codigo_carga
WHEN NOT MATCHED THEN
  INSERT (
    data_hora_coleta, data_hora_entrega, veiculo_id, carga_id
  )
  VALUES (
    ta.data_hora_coleta, ta.data_hora_entrega, ta.codigo_veiculo, ta.codigo_carga
  );
```

### Cargas

#### Cria Tabela

```sql
%sql

CREATE TABLE IF NOT EXISTS dim_cargas (
   sk_cargas BIGINT GENERATED BY DEFAULT AS IDENTITY,
   codigo_carga BIGINT,
   tipo_carga VARCHAR(50),
   peso_carga DECIMAL(10, 2),
   comprimento DECIMAL(10, 2),
   largura DECIMAL(10, 2),
   altura DECIMAL(10, 2),
   data_entrega_prevista DATE
)
USING delta
LOCATION  '/mnt/datalake7a68c04c876ba15d/gold/dim_cargas';
```

#### Cria uma tabela temporária 

```python
df_cargas.createOrReplaceTempView("temp_cargas")
```

#### Da merge nos dados da tabela dimensional e temporária

```sql 
%sql
MERGE INTO dim_cargas AS dim
USING temp_cargas AS temp
ON dim.codigo_carga = temp.codigo_carga 
WHEN MATCHED AND (dim.tipo_carga <> temp.tipo_carga OR dim.peso_carga <> temp.peso_carga OR dim.comprimento <> temp.comprimento OR dim.largura <> temp.largura OR dim.altura <> temp.altura OR dim.data_entrega_prevista <> temp.data_entrega_prevista) THEN
  UPDATE SET 
    dim.tipo_carga = temp.tipo_carga,
    dim.peso_carga = temp.peso_carga,
    dim.comprimento = temp.comprimento,
    dim.largura = temp.largura,
    dim.altura = temp.altura,
    dim.data_entrega_prevista = temp.data_entrega_prevista
WHEN NOT MATCHED THEN
  INSERT (codigo_carga, tipo_carga, peso_carga, comprimento, largura, altura, data_entrega_prevista)
  VALUES (temp.codigo_carga, temp.tipo_carga, temp.peso_carga, temp.comprimento, temp.largura, temp.altura, temp.data_entrega_prevista);
```

### Veículos

#### Cria Tabela

```sql
%sql

CREATE TABLE IF NOT EXISTS dim_veiculos (
   sk_veiculos BIGINT GENERATED BY DEFAULT AS IDENTITY,
   codigo_veiculo BIGINT,
   tipo_veiculo VARCHAR(50),
   data_aquisicao DATE,
   estado_veiculo VARCHAR(50),
   placa_veiculo VARCHAR(10)
)
USING delta
LOCATION  '/mnt/datalake7a68c04c876ba15d/gold/dim_veiculos';
```
#### Cria Tabela Temporária

```python
df_veiculos.createOrReplaceTempView("temp_veiculos")
```

#### Da merge nos dados da tabela dimensional e temporária

```sql
%sql
MERGE INTO dim_veiculos AS dim
USING temp_veiculos AS temp
ON dim.codigo_veiculo = temp.codigo_veiculo 
WHEN MATCHED AND (dim.tipo_veiculo <> temp.tipo_veiculo OR dim.data_aquisicao <> temp.data_aquisicao OR dim.estado_veiculo <> temp.estado_veiculo OR dim.placa_veiculo <> temp.placa_veiculo) THEN
  UPDATE SET 
    dim.tipo_veiculo = temp.tipo_veiculo,
    dim.data_aquisicao = temp.data_aquisicao,
    dim.estado_veiculo = temp.estado_veiculo,
    dim.placa_veiculo = temp.placa_veiculo

WHEN NOT MATCHED THEN
  INSERT (codigo_veiculo, tipo_veiculo, data_aquisicao, estado_veiculo, placa_veiculo)
  VALUES (temp.codigo_veiculo,temp.tipo_veiculo, temp.data_aquisicao, temp.estado_veiculo, temp.placa_veiculo);
```

### Motoristas

#### Criando Tabela

```sql
%sql

CREATE TABLE IF NOT EXISTS dim_motoristas (
   sk_motoristas BIGINT GENERATED BY DEFAULT AS IDENTITY,
   codigo_motorista BIGINT,
   nome VARCHAR(255),
   telefone VARCHAR(15),
   numero_carteira VARCHAR(10),
   data_contratacao DATE,
   categoria_carteira VARCHAR(30),
   status VARCHAR(30)
)
USING delta
LOCATION  '/mnt/datalake7a68c04c876ba15d/gold/dim_motoristas';
```

#### Criando Tabela Temporária de motoristas

```python
df_motoristas.createOrReplaceTempView("temp_motoristas")
```

#### Da merge nos dados da tabela dimensional e temporária

```sql
%sql
MERGE INTO dim_motoristas AS dim
USING temp_motoristas AS temp
ON dim.codigo_motorista = temp.codigo_motorista 
WHEN MATCHED AND (dim.nome <> temp.nome OR dim.telefone <> temp.telefone OR dim.numero_carteira <> temp.numero_carteira OR dim.data_contratacao <> temp.data_contratacao OR dim.categoria_carteira <> temp.categoria_carteira OR dim.status <> temp.status) THEN
  UPDATE SET 
    dim.nome = temp.nome,
    dim.telefone = temp.telefone,
    dim.numero_carteira = temp.numero_carteira,
    dim.data_contratacao = temp.data_contratacao,
    dim.categoria_carteira = temp.categoria_carteira,
    dim.status = temp.status

WHEN NOT MATCHED THEN
  INSERT (codigo_motorista, nome, telefone, numero_carteira, data_contratacao, categoria_carteira, status)
  VALUES (temp.codigo_motorista,temp.nome, temp.telefone, temp.numero_carteira, temp.data_contratacao, temp.categoria_carteira, temp.status);
```

### Rotas

#### Criando Tabela

```sql
%sql

CREATE TABLE IF NOT EXISTS dim_rotas (
   sk_rotas BIGINT GENERATED BY DEFAULT AS IDENTITY,
   codigo_rota BIGINT,
   origem CHAR(2),
   destino CHAR(2),
   tempo_estimado INT
)
USING delta
LOCATION  '/mnt/datalake7a68c04c876ba15d/gold/dim_rotas';

```

#### Criando Tabela Temporária de rotas

```python
df_rotas.createOrReplaceTempView("temp_rotas")
```

#### Da merge nos dados da tabela dimensional e temporária

```python
%sql
MERGE INTO dim_rotas AS dim
USING temp_rotas AS temp
ON dim.codigo_rota = temp.codigo_rota 
WHEN MATCHED AND (dim.origem <> temp.origem OR dim.destino <> temp.destino OR dim.tempo_estimado <> temp.tempo_estimado) THEN
  UPDATE SET 
    dim.origem = temp.origem,
    dim.destino = temp.destino,
    dim.tempo_estimado = temp.tempo_estimado

WHEN NOT MATCHED THEN
  INSERT (codigo_rota, origem, destino, tempo_estimado)
  VALUES (temp.codigo_rota,temp.origem, temp.destino, temp.tempo_estimado);
```

### Clientes

#### Criando Tabela

```sql
%sql

CREATE TABLE IF NOT EXISTS dim_clientes (
   sk_clientes BIGINT GENERATED BY DEFAULT AS IDENTITY,
   codigo_cliente BIGINT,
   nome_cliente VARCHAR(255),
   contato_cliente VARCHAR(15),
   tipo_cliente VARCHAR(50),
   logradouro_cliente VARCHAR(100),
   numero_residencia_cliente VARCHAR(5),
   bairro_cliente VARCHAR(100),
   cep_cliente VARCHAR(10),
   cidade_cliente VARCHAR(100),
   uf_cliente CHAR(2)
)
USING delta
LOCATION  '/mnt/datalake7a68c04c876ba15d/gold/dim_clientes';
```

#### Criando tabela temporária de clientes

```python
df_clientes.createOrReplaceTempView("temp_clientes")
```

#### Da merge nos dados da tabela dimensional e temporária

```python
%sql
MERGE INTO dim_clientes AS dim
USING temp_clientes AS temp
ON dim.codigo_cliente = temp.codigo_cliente 
WHEN MATCHED AND (dim.nome_cliente <> temp.nome_cliente OR dim.contato_cliente <> temp.contato_cliente OR dim.tipo_cliente <> temp.tipo_cliente OR dim.logradouro_cliente <> temp.logradouro_cliente OR dim.numero_residencia_cliente <> temp.numero_residencia_cliente OR dim.bairro_cliente <> temp.bairro_cliente OR dim.cep_cliente <> temp.cep_cliente OR dim.cidade_cliente <> temp.cidade_cliente OR dim.uf_cliente <> temp.uf_cliente ) THEN
  UPDATE SET 
    dim.nome_cliente = temp.nome_cliente,
    dim.contato_cliente = temp.contato_cliente,
    dim.tipo_cliente = temp.tipo_cliente,
    dim.logradouro_cliente = temp.logradouro_cliente,
    dim.numero_residencia_cliente = temp.numero_residencia_cliente,
    dim.bairro_cliente = temp.bairro_cliente,
    dim.cep_cliente = temp.cep_cliente,
    dim.cidade_cliente = temp.cidade_cliente,
    dim.uf_cliente = temp.uf_cliente

WHEN NOT MATCHED THEN
  INSERT (codigo_cliente, nome_cliente, contato_cliente, tipo_cliente, logradouro_cliente, numero_residencia_cliente, bairro_cliente, cep_cliente, cidade_cliente, uf_cliente)
  VALUES (temp.codigo_cliente,temp.nome_cliente, temp.contato_cliente, temp.tipo_cliente, temp.logradouro_cliente, temp.numero_residencia_cliente, temp.bairro_cliente, temp.cep_cliente, temp.cidade_cliente, temp.uf_cliente);
```

### Tempo

#### Criando Tabela

```python
from pyspark.sql.functions import min, max, row_number
from pyspark.sql import Window

menor_data = df_agendamentos.agg(min("data_hora_coleta")).collect()[0][0]

maior_data = df_agendamentos.agg(max("data_hora_entrega")).collect()[0][0]

num_dias = spark.sql(f"SELECT datediff('{maior_data}', '{menor_data}')").collect()[0][0]

df_calendario = spark.range(0, num_dias + 1) \
    .selectExpr(f"date_add(to_date('{menor_data}'), CAST(id AS INT)) AS Data")

df_tempo = df_calendario.selectExpr(
    "Data AS data",
    "year(Data) AS ano",
    "month(Data) AS mes",
       "(CASE month(Data) \
        WHEN 1 THEN 'JANEIRO' \
        WHEN 2 THEN 'FEVEREIRO' \
        WHEN 3 THEN 'MARCO' \
        WHEN 4 THEN 'ABRIL' \
        WHEN 5 THEN 'MAIO' \
        WHEN 6 THEN 'JUNHO' \
        WHEN 7 THEN 'JULHO' \
        WHEN 8 THEN 'AGOSTO' \
        WHEN 9 THEN 'SETEMBRO' \
        WHEN 10 THEN 'OUTUBRO' \
        WHEN 11 THEN 'NOVEMBRO' \
        WHEN 12 THEN 'DEZEMBRO' \
    END) AS nome_mes",
    "day(Data) AS dia",
    "(CASE dayofweek(Data) \
        WHEN 1 THEN 'DOMINGO' \
        WHEN 2 THEN 'SEGUNDA-FEIRA' \
        WHEN 3 THEN 'TERCA-FEIRA' \
        WHEN 4 THEN 'QUARTA-FEIRA' \
        WHEN 5 THEN 'QUINTA-FEIRA' \
        WHEN 6 THEN 'SEXTA-FEIRA' \
        WHEN 7 THEN 'SABADO' \
    END) AS nome_dia_semana",
    "dayofweek(Data) AS numero_dia_semana"
)

windowSpec = Window.orderBy("data")
df_tempo = df_tempo.withColumn("sk_tempo", row_number().over(windowSpec))

df_tempo.write.mode("overwrite") \
    .option("path", f"/mnt/{storageAccountName}/gold/dim_tempo") \
    .saveAsTable("dim_tempo", format="delta")
```
### Tabela Fato (Entregas)

#### Criando Tabela

```sql
%sql
CREATE TABLE IF NOT EXISTS fato_entregas (
   sk_entrega BIGINT GENERATED BY DEFAULT AS IDENTITY,
   fk_cargas BIGINT,
   fk_veiculos BIGINT,
   fk_motoristas BIGINT,
   fk_rotas BIGINT,
   fk_clientes BIGINT,
   fk_data_coleta BIGINT,
   fk_data_entrega BIGINT,
   fk_data_prevista_entrega BIGINT,
   distancia_percorrida NUMERIC(10,2),
   tempo_entrega NUMERIC(10,2),
   volume_carga NUMERIC(10,2)
)
USING delta
LOCATION '/mnt/datalake7a68c04c876ba15d/gold/fato_entregas';
```

#### Adicionando tempo_entrega e alterando data_hora para somente data

```python
from pyspark.sql.types import TimestampType
from pyspark.sql.functions import unix_timestamp, col, to_date

df_agendamentos_fato = df_agendamentos \
  .withColumn("data_hora_coleta" ,
              df_agendamentos["data_hora_coleta"]
              .cast(TimestampType()))   \
  .withColumn("data_hora_entrega",
              df_agendamentos["data_hora_entrega"]
              .cast(TimestampType()))


df_agendamentos_fato = df_agendamentos_fato.withColumn("coleta_segundos", unix_timestamp(col("data_hora_coleta"))) \
    .withColumn("entrega_segundos", unix_timestamp(col("data_hora_entrega"))) \
        .withColumn("diferenca_segundos", col("entrega_segundos") - col("coleta_segundos"))

df_agendamentos_fato = df_agendamentos_fato.withColumn("tempo_entrega", col("diferenca_segundos") / 3600)



df_agendamentos_fato = df_agendamentos_fato.withColumn("data_coleta", to_date("data_hora_coleta")) \
  .withColumn("data_entrega", to_date("data_hora_entrega"))

df_agendamentos_fato = df_agendamentos_fato.drop("entrega_segundos", "diferenca_segundos", "coleta_segundos", "data_hora_entrega", "data_hora_coleta")

df_agendamentos_fato.display()
```

#### Adicionando codigo_motorista ao DataFrame agendamentos

```python
df_agendamentos_fato = df_agendamentos_fato.join(
    df_veiculos.select("codigo_veiculo", "codigo_motorista"),
    on="codigo_veiculo",
    how="left"
)
```

#### Populando a tabela fato

```python
df_agendamentos_fato.createOrReplaceTempView("temp_agendamentos_fato")
```

```python
%sql
with cte as (
	select tc.codigo_carga, tem.sk_tempo 
	from temp_cargas tc 
	inner join dim_tempo tem 
	on tc.data_entrega_prevista = tem.data
)
insert into fato_entregas (
	fk_cargas, 
	fk_veiculos, 
	fk_motoristas, 
	fk_rotas, 
	fk_clientes, 
	fk_data_coleta, 
	fk_data_entrega, 
	fk_data_prevista_entrega, 
	distancia_percorrida, 
	tempo_entrega,
	volume_carga
	)
select 	
		car.sk_cargas,
		ve.sk_veiculos,
		mo.sk_motoristas,
		ro.sk_rotas,
		cli.sk_clientes,
		coleta.sk_tempo,
		entrega.sk_tempo,
		cte.sk_tempo,
		tr.distancia,
		fato.tempo_entrega,
		car.comprimento * car.altura * car.largura
from temp_agendamentos_fato fato
	   inner join dim_cargas car
	     on car.codigo_carga = fato.codigo_carga
       inner join dim_veiculos ve
	     on ve.codigo_veiculo = fato.codigo_veiculo
	   inner join dim_motoristas mo
	     on mo.codigo_motorista = fato.codigo_motorista
	   inner join dim_rotas ro
	   	 on ro.codigo_rota = fato.codigo_rota
	   inner join dim_clientes cli
	     on cli.codigo_cliente = fato.codigo_cliente
	   inner join cte
	   	 on cte.codigo_carga = fato.codigo_carga
	   inner join dim_tempo coleta
	     on coleta.data = fato.data_coleta
	   inner join dim_tempo entrega
	     on entrega.data = fato.data_entrega
	   inner join temp_rotas tr
	     on tr.codigo_rota = fato.codigo_rota
```